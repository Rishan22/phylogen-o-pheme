class MorphemeVisualizer {
    constructor() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.currentData = null;
        this.debounceTimer = null;
        
        this.initializeVisualization();
        this.setupEventListeners();
    }
    
    initializeVisualization() {
        this.svg = d3.select('#visualization')
            .append('svg')
            .attr('width', this.width)
            .attr('height', this.height);
            
        this.g = this.svg.append('g');
        
        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                this.g.attr('transform', event.transform);
            });
            
        this.svg.call(zoom);
        
        // Initialize tooltip
        this.tooltip = d3.select('#tooltip');
    }
    
    setupEventListeners() {
        const textInput = document.getElementById('text-input');
        
        textInput.addEventListener('input', (e) => {
            clearTimeout(this.debounceTimer);
            this.debounceTimer = setTimeout(() => {
                this.analyzeText(e.target.value);
            }, 300);
        });
        
        window.addEventListener('resize', () => {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.svg.attr('width', this.width).attr('height', this.height);
            if (this.currentData) {
                this.renderVisualization(this.currentData);
            }
        });
    }
    
    async analyzeText(text) {
        if (!text.trim()) {
            this.clearVisualization();
            return;
        }
        
        try {
            const response = await fetch('/api/analyze', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: text.trim() })
            });
            
            const data = await response.json();
            this.currentData = data;
            this.renderVisualization(data);
            this.updateStats(data);
        } catch (error) {
            console.error('Analysis failed:', error);
        }
    }
    
    renderVisualization(data) {
        this.clearVisualization();
        
        if (!data.analysis || data.analysis.length === 0) {
            return;
        }
        
        // Create unified hierarchy from all words
        const unifiedHierarchy = this.createUnifiedHierarchy(data.analysis);
        
        // Create radial tree layout
        const radius = Math.min(this.width, this.height) / 2 - 100;
        const tree = d3.tree()
            .size([2 * Math.PI, radius])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
            
        const root = d3.hierarchy(unifiedHierarchy);
        tree(root);
        
        // Center the visualization
        this.g.attr('transform', `translate(${this.width / 2}, ${this.height / 2})`);
        
        // Create links with variable thickness
        const links = this.g.selectAll('.link')
            .data(root.links())
            .enter().append('path')
            .attr('class', d => `link weight-${this.getLinkWeight(d)}`)
            .attr('d', d3.linkRadial()
                .angle(d => d.x)
                .radius(d => d.y));
        
        // Create nodes
        const nodes = this.g.selectAll('.node')
            .data(root.descendants())
            .enter().append('g')
            .attr('class', d => `node ${this.getNodeClass(d)}`)
            .attr('transform', d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`);
        
        // Add circles to nodes
        nodes.append('circle')
            .attr('r', d => this.getNodeRadius(d))
            .on('mouseover', (event, d) => this.showTooltip(event, d))
            .on('mouseout', () => this.hideTooltip())
            .on('click', (event, d) => this.handleNodeClick(event, d));
        
        // Add text labels
        nodes.append('text')
            .attr('dy', '0.31em')
            .attr('x', d => d.x < Math.PI === !d.children ? 6 : -6)
            .attr('text-anchor', d => d.x < Math.PI === !d.children ? 'start' : 'end')
            .attr('transform', d => d.x >= Math.PI ? 'rotate(180)' : null)
            .text(d => this.getNodeLabel(d))
            .style('font-size', d => this.getTextSize(d));
        
        // Add phoneme rings for detailed morphemes
        this.addPhonemeRings(nodes);
    }
    
    createUnifiedHierarchy(analyses) {
        const unified = {
            name: 'linguistic-root',
            type: 'root',
            children: []
        };
        
        const categoryGroups = {};
        const originGroups = {};
        
        for (const wordAnalysis of analyses) {
            for (const weightNode of wordAnalysis.hierarchy.children) {
                for (const categoryNode of weightNode.children) {
                    const categoryKey = `${categoryNode.name}-${categoryNode.origin}`;
                    
                    if (!categoryGroups[categoryKey]) {
                        categoryGroups[categoryKey] = {
                            name: categoryNode.name,
                            type: 'category',
                            origin: categoryNode.origin,
                            weight: weightNode.weight,
                            children: [],
                            morphemeCount: 0
                        };
                    }
                    
                    // Add morphemes to category
                    for (const morpheme of categoryNode.children) {
                        const existingMorpheme = categoryGroups[categoryKey].children
                            .find(m => m.name === morpheme.name);
                            
                        if (existingMorpheme) {
                            existingMorpheme.frequency = (existingMorpheme.frequency || 1) + 1;
                        } else {
                            categoryGroups[categoryKey].children.push({
                                ...morpheme,
                                frequency: 1,
                                word: wordAnalysis.word
                            });
                        }
                        categoryGroups[categoryKey].morphemeCount++;
                    }
                }
            }
        }
        
        // Group categories by origin
        for (const category of Object.values(categoryGroups)) {
            const origin = category.origin;
            if (!originGroups[origin]) {
                originGroups[origin] = {
                    name: origin,
                    type: 'origin',
                    children: []
                };
            }
            originGroups[origin].children.push(category);
        }
        
        unified.children = Object.values(originGroups);
        
        return unified;
    }
    
    getLinkWeight(d) {
        if (d.target.data.weight) {
            return Math.min(d.target.data.weight, 6);
        }
        if (d.target.data.type === 'morpheme') {
            return d.target.data.weight || 1;
        }
        return 1;
    }
    
    getNodeClass(d) {
        const weight = d.data.weight || 1;
        let classes = [`weight-${Math.min(weight, 6)}`];
        
        if (d.data.type === 'root') {
            classes.push('root');
        }
        if (d.data.type === 'origin') {
            classes.push('origin');
        }
        if (d.data.type === 'category') {
            classes.push('category');
        }
        if (d.data.type === 'morpheme') {
            classes.push('morpheme');
        }
        
        return classes.join(' ');
    }
    
    getNodeRadius(d) {
        if (d.data.type === 'root') return 8;
        if (d.data.type === 'origin') return 6;
        if (d.data.type === 'category') return 5;
        
        if (d.data.type === 'morpheme') {
            const weight = d.data.weight || 1;
            const frequency = d.data.frequency || 1;
            return Math.max(3, Math.min(12, weight * 2 + frequency));
        }
        
        return 4;
    }
    
    getNodeLabel(d) {
        if (d.data.type === 'root') return '';
        if (d.data.type === 'origin') return d.data.name.toUpperCase();
        if (d.data.type === 'category') return d.data.name;
        if (d.data.type === 'morpheme') {
            const freq = d.data.frequency > 1 ? `₍${d.data.frequency}₎` : '';
            return `${d.data.name}${freq}`;
        }
        return d.data.name || '';
    }
    
    getTextSize(d) {
        if (d.data.type === 'root') return '0px';
        if (d.data.type === 'origin') return '10px';
        if (d.data.type === 'category') return '9px';
        if (d.data.type === 'morpheme') {
            const weight = d.data.weight || 1;
            return `${Math.max(8, Math.min(14, 8 + weight))}px`;
        }
        return '8px';
    }
    
    addPhonemeRings(nodes) {
        nodes.each(function(d) {
            if (d.data.type === 'morpheme' && d.data.phonemes && d.data.phonemes.length > 0) {
                const node = d3.select(this);
                const radius = parseInt(node.select('circle').attr('r'));
                
                // Add phoneme ring indicators
                const phonemeRing = node.append('g').attr('class', 'phoneme-ring');
                
                const angleStep = (2 * Math.PI) / d.data.phonemes.length;
                const ringRadius = radius + 3;
                
                d.data.phonemes.forEach((phoneme, i) => {
                    const angle = i * angleStep;
                    const x = Math.cos(angle) * ringRadius;
                    const y = Math.sin(angle) * ringRadius;
                    
                    phonemeRing.append('circle')
                        .attr('cx', x)
                        .attr('cy', y)
                        .attr('r', 1.5)
                        .attr('fill', 'var(--node-secondary)')
                        .attr('opacity', 0.7);
                });
            }
        });
    }
    
    showTooltip(event, d) {
        if (d.data.type !== 'morpheme') return;
        
        const tooltip = this.tooltip;
        const morphemeData = d.data;
        
        // Build tooltip content
        let content = `<div class="morpheme-name">${morphemeData.name}</div>`;
        
        if (morphemeData.ipa) {
            content += `<div class="ipa">/${morphemeData.ipa}/</div>`;
        }
        
        let details = [];
        if (morphemeData.meaning) details.push(`Meaning: ${morphemeData.meaning}`);
        if (morphemeData.origin) details.push(`Origin: ${morphemeData.origin}`);
        if (morphemeData.category) details.push(`Category: ${morphemeData.category}`);
        if (morphemeData.weight) details.push(`Weight: ${morphemeData.weight}`);
        if (morphemeData.frequency && morphemeData.frequency > 1) {
            details.push(`Frequency: ${morphemeData.frequency}`);
        }
        if (morphemeData.word) details.push(`Found in: ${morphemeData.word}`);
        if (morphemeData.alternateSpellings) {
            details.push(`Variants: ${morphemeData.alternateSpellings.join(', ')}`);
        }
        
        content += `<div class="details">${details.join('<br>')}</div>`;
        
        tooltip.html(content)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px')
            .classed('visible', true);
    }
    
    hideTooltip() {
        this.tooltip.classed('visible', false);
    }
    
    handleNodeClick(event, d) {
        // Focus on clicked node - could expand to show more details
        console.log('Node clicked:', d.data);
    }
    
    updateStats(data) {
        const statsPanel = document.getElementById('stats-panel');
        
        if (!data.analysis || data.analysis.length === 0) {
            statsPanel.classList.remove('visible');
            return;
        }
        
        // Calculate statistics
        let totalMorphemes = 0;
        let totalPhonemes = 0;
        let totalComplexity = 0;
        const origins = new Set();
        
        for (const wordAnalysis of data.analysis) {
            totalMorphemes += wordAnalysis.morphemes.length;
            
            if (wordAnalysis.phonemeAnalysis) {
                totalPhonemes += wordAnalysis.phonemeAnalysis.totalPhonemes;
                totalComplexity += wordAnalysis.phonemeAnalysis.phoneticComplexity;
            }
            
            for (const morpheme of wordAnalysis.morphemes) {
                origins.add(morpheme.data.origin);
            }
        }
        
        // Update display
        document.getElementById('morpheme-count').textContent = totalMorphemes;
        document.getElementById('phoneme-count').textContent = totalPhonemes;
        document.getElementById('complexity-score').textContent = Math.round(totalComplexity);
        document.getElementById('origin-count').textContent = origins.size;
        
        statsPanel.classList.add('visible');
    }
    
    clearVisualization() {
        this.g.selectAll('*').remove();
        document.getElementById('stats-panel').classList.remove('visible');
    }
}

// Initialize the visualizer when the page loads
document.addEventListener('DOMContentLoaded', () => {
    const visualizer = new MorphemeVisualizer();
    
    // Demo text for initial load
    const demoText = "neuropsychopharmacological";
    document.getElementById('text-input').value = demoText;
    visualizer.analyzeText(demoText);
});